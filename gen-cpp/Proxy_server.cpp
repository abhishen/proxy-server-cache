// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Proxy.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/select.h>
#include <curl/curl.h>
#include <time.h>
#include <queue>
#include <map>

using namespace std;

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::rpc;
long cacheSize, sizeOfCache;

class ProxyHandler : virtual public ProxyIf {

private:
	std::queue <string> entryQueue; // Used for FIFO
	std::map <string, string> cache; // Actual cache for web-documents
	long maxsize;
	int32_t count = 0;
	int32_t cacheHits = 0;
	int32_t cacheMisses = 0;

public:
	ProxyHandler() {
    // Your initialization goes here
  	}	

 	static size_t writebuf(void *buffer, size_t size, size_t nmemb, void *userp){
  		((string*)userp)->append((char*)buffer, size * nmemb);
  		return size*nmemb;
  	}

  	int32_t ping() {
    	// Your implementation goes here
    	//printf("ping\n");
  	}

  	int32_t currentTime() {
    	// Your implementation goes here
	}

	long getCurrentSize() {
		long currentSize = cacheSize - maxsize;
		return currentSize;
	}

	void addCacheEntry (long entry) {
		maxsize = maxsize + entry;
	}	

	void fifoEviction() {
		printf("Entry to be deleted: url:%s\n",entryQueue.front().c_str());
		printf("Size before deletion is %d\n",getCurrentSize());
		printf("Total %d will be deleted\n", cache[entryQueue.front()].size());
		maxsize = maxsize - cache[entryQueue.front()].size();
		printf("Size after deletion is %d\n",getCurrentSize());
		cache.erase(entryQueue.front());
		entryQueue.pop();
	}

	void getURL(std::string& _return, const std::string& url) {
    	// Your implementation goes here
		string out;
		//Look for url in cache
 		std::map<string, string>::iterator it;
		it = cache.find(url);
		//If not found
		if (it == cache.end()) {
			printf("------CACHE MISS-----\n");
			cacheMisses++;
			printf("%s not found, fetching from the Internet\n",url.c_str());
			CURL *curl = curl_easy_init();
    		printf("getURL\n");
			if(curl) {
        		CURLcode res;
        		printf("url is %s\n", url.c_str());
        		curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
				curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
        		curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writebuf);
				curl_easy_setopt(curl, CURLOPT_WRITEDATA, &out);
       	 		res = curl_easy_perform(curl);
       			curl_easy_cleanup(curl);
				
				//Check if cache has space
				printf("Current size available in cache %d\n", getCurrentSize());
				printf("Size of document %d\n", out.size());
				
				if(out.size()>sizeOfCache) {
					printf("Size Exceeded!\n");
				} else {
				// If cache has space
				if(getCurrentSize() > out.size()) {
					printf("Cache has space\n");
					cache.insert(std::pair<string,string>(url,out.c_str()));
					entryQueue.push(url);
					string entry = entryQueue.front();
					printf("Just inserted %s at %d. Actual entry %s\n",url.c_str(), count, entry.c_str());
					count++;
					addCacheEntry(cache[url].size());
					printf("Size of cache after adding new entry for %s is %d\n",url.c_str(), getCurrentSize());

				// If no space in cache
				} else {
					//Evict random entry
					while(1) {
						if(out.size() >= getCurrentSize()) {
							printf("Evict!\n");
							fifoEviction();
				//If there is space in cache
						} else if(getCurrentSize()>out.size()) {
							cache.insert(std::pair<string,string>(url,out.c_str()));
							entryQueue.push(url);
							printf("Just inserted %s. Actual entry %s\n",url.c_str(), entryQueue.front().c_str());
							count++;
							addCacheEntry(cache[url].size());
							break;
						}
					}
    			}
			}

			} else {
        		printf("Could not get cURL handle!\n");
        		exit(EXIT_FAILURE);
			}
		//If found
		} else {
			cacheHits++;
			printf("---------CACHE HIT------------\n");
			printf("URL requested %s; Found %s\n", url.c_str(), it->first.c_str());				
		}
	printf("Cache hits: %d\n", cacheHits);
	printf("Cache misses: %d\n", cacheMisses);
	}

};

int main(int argc, char **argv) {
	if(argc == 2) {
		cacheSize = atol(argv[1]);
	} else {
		cacheSize = 1024000;
	}
	int port = 9090;
  	shared_ptr<ProxyHandler> handler(new ProxyHandler());
  	shared_ptr<TProcessor> processor(new ProxyProcessor(handler));
  	shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  	shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  	TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  	server.serve();
  	return 0;
}
